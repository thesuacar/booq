
# Create the orchestrator notebook that handles AI model integration
orchestrator_code = '''
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Audiobook Orchestrator - AI Model Integration\\n",
    "\\n",
    "This notebook serves as the orchestrator between the Streamlit UI and the AI audio generation model.\\n",
    "It handles:\\n",
    "- PDF text extraction\\n",
    "- Text preprocessing\\n",
    "- AI audio generation\\n",
    "- Audio file storage and management\\n",
    "- Progress tracking"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Required Libraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Install required libraries (run once)\\n",
    "# !pip install PyPDF2 pydub langdetect gtts pyttsx3 transformers torch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\\n",
    "import json\\n",
    "import hashlib\\n",
    "from pathlib import Path\\n",
    "from datetime import datetime\\n",
    "import PyPDF2\\n",
    "from typing import Dict, List, Optional\\n",
    "import logging\\n",
    "\\n",
    "# Setup logging\\n",
    "logging.basicConfig(level=logging.INFO)\\n",
    "logger = logging.getLogger(__name__)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. PDF Processing Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class PDFProcessor:\\n",
    "    \\"\\"\\"Handles PDF text extraction and preprocessing\\"\\"\\"\\n",
    "    \\n",
    "    @staticmethod\\n",
    "    def extract_text_from_pdf(pdf_path: str) -> Dict[int, str]:\\n",
    "        \\"\\"\\"\\n",
    "        Extract text from PDF file page by page\\n",
    "        \\n",
    "        Args:\\n",
    "            pdf_path: Path to PDF file\\n",
    "        \\n",
    "        Returns:\\n",
    "            Dictionary mapping page numbers to text content\\n",
    "        \\"\\"\\"\\n",
    "        try:\\n",
    "            page_texts = {}\\n",
    "            \\n",
    "            with open(pdf_path, 'rb') as file:\\n",
    "                pdf_reader = PyPDF2.PdfReader(file)\\n",
    "                total_pages = len(pdf_reader.pages)\\n",
    "                \\n",
    "                logger.info(f\\"Extracting text from {total_pages} pages\\")\\n",
    "                \\n",
    "                for page_num in range(total_pages):\\n",
    "                    page = pdf_reader.pages[page_num]\\n",
    "                    text = page.extract_text()\\n",
    "                    page_texts[page_num + 1] = text\\n",
    "                    \\n",
    "                logger.info(f\\"Successfully extracted text from {total_pages} pages\\")\\n",
    "                return page_texts\\n",
    "                \\n",
    "        except Exception as e:\\n",
    "            logger.error(f\\"Error extracting PDF text: {str(e)}\\")\\n",
    "            raise\\n",
    "    \\n",
    "    @staticmethod\\n",
    "    def get_pdf_metadata(pdf_path: str) -> Dict:\\n",
    "        \\"\\"\\"\\n",
    "        Extract metadata from PDF\\n",
    "        \\n",
    "        Args:\\n",
    "            pdf_path: Path to PDF file\\n",
    "        \\n",
    "        Returns:\\n",
    "            Dictionary with PDF metadata\\n",
    "        \\"\\"\\"\\n",
    "        try:\\n",
    "            with open(pdf_path, 'rb') as file:\\n",
    "                pdf_reader = PyPDF2.PdfReader(file)\\n",
    "                \\n",
    "                metadata = {\\n",
    "                    'total_pages': len(pdf_reader.pages),\\n",
    "                    'title': pdf_reader.metadata.get('/Title', ''),\\n",
    "                    'author': pdf_reader.metadata.get('/Author', ''),\\n",
    "                    'subject': pdf_reader.metadata.get('/Subject', ''),\\n",
    "                }\\n",
    "                \\n",
    "                return metadata\\n",
    "                \\n",
    "        except Exception as e:\\n",
    "            logger.error(f\\"Error extracting PDF metadata: {str(e)}\\")\\n",
    "            return {}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Audio Generation Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class AudioGenerator:\\n",
    "    \\"\\"\\"Handles AI-based audio generation from text\\"\\"\\"\\n",
    "    \\n",
    "    def __init__(self, model_path: Optional[str] = None):\\n",
    "        \\"\\"\\"\\n",
    "        Initialize audio generator\\n",
    "        \\n",
    "        Args:\\n",
    "            model_path: Path to pre-trained TTS model (if available)\\n",
    "        \\"\\"\\"\\n",
    "        self.model_path = model_path\\n",
    "        self.model = None\\n",
    "        \\n",
    "        # Create cache directory for generated audio\\n",
    "        self.cache_dir = Path('data/audio_cache')\\n",
    "        self.cache_dir.mkdir(parents=True, exist_ok=True)\\n",
    "    \\n",
    "    def load_model(self):\\n",
    "        \\"\\"\\"\\n",
    "        Load the TTS model\\n",
    "        In production, this would load your trained AI model\\n",
    "        \\"\\"\\"\\n",
    "        logger.info(\\"Loading TTS model...\\")\\n",
    "        # TODO: Replace with your actual model loading code\\n",
    "        # Example:\\n",
    "        # from your_model import TTSModel\\n",
    "        # self.model = TTSModel.load(self.model_path)\\n",
    "        logger.info(\\"Model loaded successfully\\")\\n",
    "    \\n",
    "    def generate_audio_from_text(\\n",
    "        self, \\n",
    "        text: str, \\n",
    "        language: str = 'en',\\n",
    "        voice: str = 'default',\\n",
    "        speed: float = 1.0\\n",
    "    ) -> bytes:\\n",
    "        \\"\\"\\"\\n",
    "        Generate audio from text using AI model\\n",
    "        \\n",
    "        Args:\\n",
    "            text: Text to convert to speech\\n",
    "            language: Language code (en, es, fr, etc.)\\n",
    "            voice: Voice identifier\\n",
    "            speed: Playback speed multiplier\\n",
    "        \\n",
    "        Returns:\\n",
    "            Audio data as bytes\\n",
    "        \\"\\"\\"\\n",
    "        # Check cache first\\n",
    "        cache_key = self._generate_cache_key(text, language, voice, speed)\\n",
    "        cached_audio = self._get_from_cache(cache_key)\\n",
    "        \\n",
    "        if cached_audio:\\n",
    "            logger.info(\\"Using cached audio\\")\\n",
    "            return cached_audio\\n",
    "        \\n",
    "        logger.info(f\\"Generating audio for text (length: {len(text)} chars)\\")\\n",
    "        \\n",
    "        # TODO: Replace with your actual model inference\\n",
    "        # Example:\\n",
    "        # audio_data = self.model.synthesize(\\n",
    "        #     text=text,\\n",
    "        #     language=language,\\n",
    "        #     voice=voice,\\n",
    "        #     speed=speed\\n",
    "        # )\\n",
    "        \\n",
    "        # Placeholder: Generate silence or use a simple TTS\\n",
    "        audio_data = self._placeholder_tts(text, language)\\n",
    "        \\n",
    "        # Cache the generated audio\\n",
    "        self._save_to_cache(cache_key, audio_data)\\n",
    "        \\n",
    "        return audio_data\\n",
    "    \\n",
    "    def _placeholder_tts(self, text: str, language: str) -> bytes:\\n",
    "        \\"\\"\\"\\n",
    "        Placeholder TTS function using gTTS\\n",
    "        Replace this with your actual model\\n",
    "        \\"\\"\\"\\n",
    "        try:\\n",
    "            from gtts import gTTS\\n",
    "            from io import BytesIO\\n",
    "            \\n",
    "            lang_map = {\\n",
    "                'English': 'en',\\n",
    "                'Spanish': 'es',\\n",
    "                'French': 'fr',\\n",
    "                'German': 'de',\\n",
    "                'Italian': 'it',\\n",
    "                'Portuguese': 'pt',\\n",
    "                'Korean': 'ko',\\n",
    "                'Japanese': 'ja'\\n",
    "            }\\n",
    "            \\n",
    "            lang_code = lang_map.get(language, 'en')\\n",
    "            tts = gTTS(text=text, lang=lang_code, slow=False)\\n",
    "            \\n",
    "            audio_fp = BytesIO()\\n",
    "            tts.write_to_fp(audio_fp)\\n",
    "            audio_fp.seek(0)\\n",
    "            \\n",
    "            return audio_fp.read()\\n",
    "            \\n",
    "        except Exception as e:\\n",
    "            logger.error(f\\"Error in placeholder TTS: {str(e)}\\")\\n",
    "            # Return empty bytes if TTS fails\\n",
    "            return b''\\n",
    "    \\n",
    "    def _generate_cache_key(self, text: str, language: str, voice: str, speed: float) -> str:\\n",
    "        \\"\\"\\"Generate unique cache key for audio\\"\\"\\"\\n",
    "        key_string = f\\"{text}_{language}_{voice}_{speed}\\"\\n",
    "        return hashlib.md5(key_string.encode()).hexdigest()\\n",
    "    \\n",
    "    def _get_from_cache(self, cache_key: str) -> Optional[bytes]:\\n",
    "        \\"\\"\\"Retrieve audio from cache\\"\\"\\"\\n",
    "        cache_file = self.cache_dir / f\\"{cache_key}.mp3\\"\\n",
    "        if cache_file.exists():\\n",
    "            with open(cache_file, 'rb') as f:\\n",
    "                return f.read()\\n",
    "        return None\\n",
    "    \\n",
    "    def _save_to_cache(self, cache_key: str, audio_data: bytes):\\n",
    "        \\"\\"\\"Save audio to cache\\"\\"\\"\\n",
    "        cache_file = self.cache_dir / f\\"{cache_key}.mp3\\"\\n",
    "        with open(cache_file, 'wb') as f:\\n",
    "            f.write(audio_data)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Audiobook Manager"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class AudiobookManager:\\n",
    "    \\"\\"\\"Main orchestrator for audiobook creation\\"\\"\\"\\n",
    "    \\n",
    "    def __init__(self, model_path: Optional[str] = None):\\n",
    "        self.pdf_processor = PDFProcessor()\\n",
    "        self.audio_generator = AudioGenerator(model_path)\\n",
    "        \\n",
    "        # Create necessary directories\\n",
    "        Path('data/audio').mkdir(parents=True, exist_ok=True)\\n",
    "        Path('data/pdfs').mkdir(parents=True, exist_ok=True)\\n",
    "    \\n",
    "    def create_audiobook(\\n",
    "        self,\\n",
    "        pdf_path: str,\\n",
    "        book_id: str,\\n",
    "        language: str = 'English',\\n",
    "        voice: str = 'default',\\n",
    "        speed: float = 1.0,\\n",
    "        progress_callback = None\\n",
    "    ) -> Dict:\\n",
    "        \\"\\"\\"\\n",
    "        Create complete audiobook from PDF\\n",
    "        \\n",
    "        Args:\\n",
    "            pdf_path: Path to PDF file\\n",
    "            book_id: Unique identifier for the book\\n",
    "            language: Language for audio generation\\n",
    "            voice: Voice to use\\n",
    "            speed: Playback speed\\n",
    "            progress_callback: Function to call with progress updates\\n",
    "        \\n",
    "        Returns:\\n",
    "            Dictionary with audiobook information\\n",
    "        \\"\\"\\"\\n",
    "        try:\\n",
    "            # Step 1: Extract text from PDF\\n",
    "            if progress_callback:\\n",
    "                progress_callback(10, \\"Extracting text from PDF...\\")\\n",
    "            \\n",
    "            page_texts = self.pdf_processor.extract_text_from_pdf(pdf_path)\\n",
    "            metadata = self.pdf_processor.get_pdf_metadata(pdf_path)\\n",
    "            \\n",
    "            # Step 2: Combine all text\\n",
    "            if progress_callback:\\n",
    "                progress_callback(20, \\"Processing text...\\")\\n",
    "            \\n",
    "            full_text = '\\\\n\\\\n'.join(page_texts.values())\\n",
    "            \\n",
    "            # Step 3: Generate audio\\n",
    "            if progress_callback:\\n",
    "                progress_callback(30, \\"Generating audio with AI...\\")\\n",
    "            \\n",
    "            # For large texts, you might want to split and generate in chunks\\n",
    "            audio_data = self.audio_generator.generate_audio_from_text(\\n",
    "                text=full_text,\\n",
    "                language=language,\\n",
    "                voice=voice,\\n",
    "                speed=speed\\n",
    "            )\\n",
    "            \\n",
    "            # Step 4: Save audio file\\n",
    "            if progress_callback:\\n",
    "                progress_callback(80, \\"Saving audiobook...\\")\\n",
    "            \\n",
    "            audio_path = Path('data/audio') / f\\"{book_id}.mp3\\"\\n",
    "            with open(audio_path, 'wb') as f:\\n",
    "                f.write(audio_data)\\n",
    "            \\n",
    "            if progress_callback:\\n",
    "                progress_callback(100, \\"Audiobook created successfully!\\")\\n",
    "            \\n",
    "            return {\\n",
    "                'success': True,\\n",
    "                'audio_path': str(audio_path),\\n",
    "                'total_pages': metadata.get('total_pages', len(page_texts)),\\n",
    "                'duration': self._estimate_duration(len(full_text)),\\n",
    "                'metadata': metadata\\n",
    "            }\\n",
    "            \\n",
    "        except Exception as e:\\n",
    "            logger.error(f\\"Error creating audiobook: {str(e)}\\")\\n",
    "            return {\\n",
    "                'success': False,\\n",
    "                'error': str(e)\\n",
    "            }\\n",
    "    \\n",
    "    def _estimate_duration(self, text_length: int, wpm: int = 150) -> str:\\n",
    "        \\"\\"\\"\\n",
    "        Estimate audio duration based on text length\\n",
    "        \\n",
    "        Args:\\n",
    "            text_length: Number of characters\\n",
    "            wpm: Words per minute (average reading speed)\\n",
    "        \\n",
    "        Returns:\\n",
    "            Duration as string (HH:MM:SS)\\n",
    "        \\"\\"\\"\\n",
    "        # Rough estimate: 5 characters per word\\n",
    "        words = text_length / 5\\n",
    "        minutes = words / wpm\\n",
    "        seconds = int(minutes * 60)\\n",
    "        \\n",
    "        hours = seconds // 3600\\n",
    "        minutes = (seconds % 3600) // 60\\n",
    "        secs = seconds % 60\\n",
    "        \\n",
    "        return f\\"{hours:02d}:{minutes:02d}:{secs:02d}\\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Usage Examples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Example: Create an audiobook\\n",
    "def example_usage():\\n",
    "    \\"\\"\\"Example of how to use the AudiobookManager\\"\\"\\"\\n",
    "    \\n",
    "    # Initialize manager\\n",
    "    manager = AudiobookManager()\\n",
    "    \\n",
    "    # Define progress callback\\n",
    "    def progress_handler(percent, message):\\n",
    "        print(f\\"[{percent}%] {message}\\")\\n",
    "    \\n",
    "    # Create audiobook\\n",
    "    result = manager.create_audiobook(\\n",
    "        pdf_path='data/pdfs/sample_book.pdf',\\n",
    "        book_id='book_123',\\n",
    "        language='English',\\n",
    "        voice='Ana',\\n",
    "        speed=1.0,\\n",
    "        progress_callback=progress_handler\\n",
    "    )\\n",
    "    \\n",
    "    if result['success']:\\n",
    "        print(f\\"Audiobook created successfully!\\")\\n",
    "        print(f\\"Audio file: {result['audio_path']}\\")\\n",
    "        print(f\\"Duration: {result['duration']}\\")\\n",
    "        print(f\\"Total pages: {result['total_pages']}\\")\\n",
    "    else:\\n",
    "        print(f\\"Error: {result['error']}\\")\\n",
    "\\n",
    "# Uncomment to run\\n",
    "# example_usage()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Integration with Streamlit UI\\n",
    "\\n",
    "To integrate this orchestrator with the Streamlit UI, you can:\\n",
    "\\n",
    "1. Import the `AudiobookManager` class in your Streamlit app\\n",
    "2. Call `create_audiobook()` when a user uploads a PDF\\n",
    "3. Use the progress callback to update the UI\\n",
    "4. Store the result in the library JSON\\n",
    "\\n",
    "Example integration in Streamlit:\\n",
    "\\n",
    "```python\\n",
    "# In audiobook_app.py\\n",
    "from audiobook_orchestrator import AudiobookManager\\n",
    "\\n",
    "manager = AudiobookManager()\\n",
    "\\n",
    "# When user clicks \\"Create Audiobook\\"\\n",
    "result = manager.create_audiobook(\\n",
    "    pdf_path=pdf_path,\\n",
    "    book_id=book_id,\\n",
    "    language=selected_language,\\n",
    "    progress_callback=lambda p, m: update_streamlit_progress(p, m)\\n",
    ")\\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Testing Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def test_pdf_extraction():\\n",
    "    \\"\\"\\"Test PDF text extraction\\"\\"\\"\\n",
    "    processor = PDFProcessor()\\n",
    "    \\n",
    "    # Replace with your test PDF path\\n",
    "    test_pdf = 'data/pdfs/test.pdf'\\n",
    "    \\n",
    "    if Path(test_pdf).exists():\\n",
    "        page_texts = processor.extract_text_from_pdf(test_pdf)\\n",
    "        print(f\\"Extracted {len(page_texts)} pages\\")\\n",
    "        print(f\\"First page preview: {page_texts[1][:200]}...\\")\\n",
    "    else:\\n",
    "        print(f\\"Test PDF not found at {test_pdf}\\")\\n",
    "\\n",
    "def test_audio_generation():\\n",
    "    \\"\\"\\"Test audio generation\\"\\"\\"\\n",
    "    generator = AudioGenerator()\\n",
    "    \\n",
    "    test_text = \\"This is a test sentence for audio generation.\\"\\n",
    "    audio_data = generator.generate_audio_from_text(test_text, language='English')\\n",
    "    \\n",
    "    print(f\\"Generated audio size: {len(audio_data)} bytes\\")\\n",
    "    \\n",
    "    # Save test audio\\n",
    "    with open('data/test_audio.mp3', 'wb') as f:\\n",
    "        f.write(audio_data)\\n",
    "    \\n",
    "    print(\\"Test audio saved to data/test_audio.mp3\\")\\n",
    "\\n",
    "# Uncomment to run tests\\n",
    "# test_pdf_extraction()\\n",
    "# test_audio_generation()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
'''

# Save the notebook
with open('audiobook_orchestrator.ipynb', 'w', encoding='utf-8') as f:
    f.write(orchestrator_code)

print("âœ… Created: audiobook_orchestrator.ipynb")
